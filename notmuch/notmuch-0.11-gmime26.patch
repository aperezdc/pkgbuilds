commit 33a58d0e2dd1e0084bd841aa251ae52ae55a74fd
Author: Adrian Perez <aperez@igalia.com>
Date:   Tue Jan 17 03:40:05 2012 +0200

    Update notmuch to use the GMime 2.6 API
    
    GMime version 2.6 introduces a number of API changes which affect mostly
    the signing/encryption support. This patch makes the hanges needed to build
    and link with version 2.6 of it.

diff --git a/notmuch-client.h b/notmuch-client.h
index c602e2e..3586fea 100644
--- a/notmuch-client.h
+++ b/notmuch-client.h
@@ -69,7 +69,7 @@ typedef struct notmuch_show_format {
     void (*part_start) (GMimeObject *part,
 			int *part_count);
     void (*part_encstatus) (int status);
-    void (*part_sigstatus) (const GMimeSignatureValidity* validity);
+    void (*part_sigstatus) (GMimeSignatureList* validity);
     void (*part_content) (GMimeObject *part);
     void (*part_end) (GMimeObject *part);
     const char *part_sep;
@@ -83,7 +83,7 @@ typedef struct notmuch_show_params {
     int entire_thread;
     int raw;
     int part;
-    GMimeCipherContext* cryptoctx;
+    GMimeCryptoContext* cryptoctx;
     int decrypt;
 } notmuch_show_params_t;
 
diff --git a/notmuch-reply.c b/notmuch-reply.c
index 7242310..bfc8868 100644
--- a/notmuch-reply.c
+++ b/notmuch-reply.c
@@ -645,15 +645,12 @@ notmuch_reply_command (void *ctx, int argc, char *argv[])
 	    }
 	} else if ((STRNCMP_LITERAL (argv[i], "--decrypt") == 0)) {
 	    if (params.cryptoctx == NULL) {
-		GMimeSession* session = g_object_new(g_mime_session_get_type(), NULL);
-		if (NULL == (params.cryptoctx = g_mime_gpg_context_new(session, "gpg"))) {
+		if (NULL == (params.cryptoctx = g_mime_gpg_context_new(NULL, "gpg"))) {
 		    fprintf (stderr, "Failed to construct gpg context.\n");
 		} else {
 		    params.decrypt = TRUE;
 		    g_mime_gpg_context_set_always_trust((GMimeGpgContext*)params.cryptoctx, FALSE);
 		}
-		g_object_unref (session);
-		session = NULL;
 	    }
 	} else {
 	    fprintf (stderr, "Unrecognized option: %s\n", argv[i]);
diff --git a/notmuch-show.c b/notmuch-show.c
index 19fb49f..fda8f57 100644
--- a/notmuch-show.c
+++ b/notmuch-show.c
@@ -76,7 +76,7 @@ static void
 format_part_encstatus_json (int status);
 
 static void
-format_part_sigstatus_json (const GMimeSignatureValidity* validity);
+format_part_sigstatus_json (GMimeSignatureList* validity);
 
 static void
 format_part_content_json (GMimeObject *part);
@@ -487,16 +487,14 @@ show_text_part_content (GMimeObject *part, GMimeStream *stream_out)
 }
 
 static const char*
-signer_status_to_string (GMimeSignerStatus x)
+signer_status_to_string (GMimeSignatureStatus x)
 {
     switch (x) {
-    case GMIME_SIGNER_STATUS_NONE:
-	return "none";
-    case GMIME_SIGNER_STATUS_GOOD:
+    case GMIME_SIGNATURE_STATUS_GOOD:
 	return "good";
-    case GMIME_SIGNER_STATUS_BAD:
+    case GMIME_SIGNATURE_STATUS_BAD:
 	return "bad";
-    case GMIME_SIGNER_STATUS_ERROR:
+    case GMIME_SIGNATURE_STATUS_ERROR:
 	return "error";
     }
     return "unknown";
@@ -593,7 +591,7 @@ format_part_encstatus_json (int status)
 }
 
 static void
-format_part_sigstatus_json (const GMimeSignatureValidity* validity)
+format_part_sigstatus_json (GMimeSignatureList* validity)
 {
     printf (", \"sigstatus\": [");
 
@@ -602,50 +600,50 @@ format_part_sigstatus_json (const GMimeSignatureValidity* validity)
 	return;
     }
 
-    const GMimeSigner *signer = g_mime_signature_validity_get_signers (validity);
-    int first = 1;
+    int i;
     void *ctx_quote = talloc_new (NULL);
 
-    while (signer) {
-	if (first)
-	    first = 0;
-	else
+    for (i = 0; i < g_mime_signature_list_length (validity); i++) {
+	GMimeSignature *signature = g_mime_signature_list_get_signature (validity, i);
+	if (i > 0)
 	    printf (", ");
 
 	printf ("{");
 
 	/* status */
+	const GMimeSignatureStatus status = g_mime_signature_get_status (signature);
 	printf ("\"status\": %s",
 		json_quote_str (ctx_quote,
-				signer_status_to_string (signer->status)));
+				signer_status_to_string (status)));
 
-	if (signer->status == GMIME_SIGNER_STATUS_GOOD)
+	GMimeCertificate *cert = g_mime_signature_get_certificate (signature);
+
+	if (status == GMIME_SIGNATURE_STATUS_GOOD)
 	{
-	    if (signer->fingerprint)
-		printf (", \"fingerprint\": %s", json_quote_str (ctx_quote, signer->fingerprint));
+	    if (g_mime_certificate_get_fingerprint (cert))
+		printf (", \"fingerprint\": %s", json_quote_str (ctx_quote, g_mime_certificate_get_fingerprint (cert)));
 	    /* these dates are seconds since the epoch; should we
 	     * provide a more human-readable format string? */
-	    if (signer->created)
-		printf (", \"created\": %d", (int) signer->created);
-	    if (signer->expires)
-		printf (", \"expires\": %d", (int) signer->expires);
+	    if (g_mime_certificate_get_created (cert) != (time_t) -1)
+		printf (", \"created\": %d", (int) g_mime_certificate_get_created (cert));
+	    if (g_mime_certificate_get_expires (cert) != (time_t) -1)
+		printf (", \"expires\": %d", (int) g_mime_certificate_get_expires (cert));
 	    /* output user id only if validity is FULL or ULTIMATE. */
 	    /* note that gmime is using the term "trust" here, which
 	     * is WRONG.  It's actually user id "validity". */
-	    if ((signer->name) && (signer->trust)) {
-		if ((signer->trust == GMIME_SIGNER_TRUST_FULLY) || (signer->trust == GMIME_SIGNER_TRUST_ULTIMATE))
-		    printf (", \"userid\": %s", json_quote_str (ctx_quote, signer->name));
-           }
-       } else {
-           if (signer->keyid)
-               printf (", \"keyid\": %s", json_quote_str (ctx_quote, signer->keyid));
-       }
-       if (signer->errors != GMIME_SIGNER_ERROR_NONE) {
-           printf (", \"errors\": %x", signer->errors);
-       }
-
-       printf ("}");
-       signer = signer->next;
+	    if ((g_mime_certificate_get_name (cert)) &&
+		((g_mime_certificate_get_trust (cert) == GMIME_CERTIFICATE_TRUST_FULLY) ||
+		 (g_mime_certificate_get_trust (cert) == GMIME_CERTIFICATE_TRUST_ULTIMATE)))
+		printf (", \"userid\": %s", json_quote_str (ctx_quote, g_mime_certificate_get_name (cert)));
+	} else {
+	    if (g_mime_certificate_get_key_id (cert))
+		printf (", \"keyid\": %s", json_quote_str (ctx_quote, g_mime_certificate_get_key_id (cert)));
+	}
+	if (g_mime_signature_get_errors (signature) != GMIME_SIGNATURE_ERROR_NONE) {
+	    printf (", \"errors\": %x", g_mime_signature_get_errors (signature));
+	}
+
+	printf ("}");
     }
 
     printf ("]");
@@ -973,13 +971,10 @@ notmuch_show_command (void *ctx, unused (int argc), unused (char *argv[]))
 	} else if ((STRNCMP_LITERAL (argv[i], "--verify") == 0) ||
 		   (STRNCMP_LITERAL (argv[i], "--decrypt") == 0)) {
 	    if (params.cryptoctx == NULL) {
-		GMimeSession* session = g_object_new(g_mime_session_get_type(), NULL);
-		if (NULL == (params.cryptoctx = g_mime_gpg_context_new(session, "gpg")))
+		if (NULL == (params.cryptoctx = g_mime_gpg_context_new(NULL, "gpg")))
 		    fprintf (stderr, "Failed to construct gpg context.\n");
 		else
 		    g_mime_gpg_context_set_always_trust((GMimeGpgContext*)params.cryptoctx, FALSE);
-		g_object_unref (session);
-		session = NULL;
 	    }
 	    if (STRNCMP_LITERAL (argv[i], "--decrypt") == 0)
 		params.decrypt = 1;
diff --git a/show-message.c b/show-message.c
index d83f04e..04a41e4 100644
--- a/show-message.c
+++ b/show-message.c
@@ -67,21 +67,22 @@ show_message_part (GMimeObject *part,
 			 "Error: %d part(s) for a multipart/encrypted message (should be exactly 2)\n",
 			 g_mime_multipart_get_count (multipart));
 	    } else {
+		GMimeDecryptResult *decryptresult = NULL;
 		GMimeMultipartEncrypted *encrypteddata = GMIME_MULTIPART_ENCRYPTED (part);
-		decryptedpart = g_mime_multipart_encrypted_decrypt (encrypteddata, params->cryptoctx, &err);
+		decryptedpart = g_mime_multipart_encrypted_decrypt (encrypteddata, params->cryptoctx, &decryptresult, &err);
 		if (decryptedpart) {
 		    if ((selected || state->in_zone) && format->part_encstatus)
 			format->part_encstatus (1);
-		    const GMimeSignatureValidity *sigvalidity = g_mime_multipart_encrypted_get_signature_validity (encrypteddata);
-		    if (!sigvalidity)
+		    if (!decryptresult->signatures)
 			fprintf (stderr, "Failed to verify signed part: %s\n", (err ? err->message : "no error explanation given"));
 		    if ((selected || state->in_zone) && format->part_sigstatus)
-			format->part_sigstatus (sigvalidity);
+			format->part_sigstatus (decryptresult->signatures);
 		} else {
 		    fprintf (stderr, "Failed to decrypt part: %s\n", (err ? err->message : "no error explanation given"));
 		    if ((selected || state->in_zone) && format->part_encstatus)
 			format->part_encstatus (0);
 		}
+		g_object_unref (decryptresult);
 	    }
 	}
 	else if (GMIME_IS_MULTIPART_SIGNED (part))
@@ -98,14 +99,14 @@ show_message_part (GMimeObject *part,
 		 * g_mime_multipart_encrypted_get_signature_validity,
 		 * and therefore needs to be properly disposed of.
 		 * Hopefully the API will become more consistent. */
-		GMimeSignatureValidity *sigvalidity = g_mime_multipart_signed_verify (GMIME_MULTIPART_SIGNED (part), params->cryptoctx, &err);
+		GMimeSignatureList *sigvalidity = g_mime_multipart_signed_verify (GMIME_MULTIPART_SIGNED (part), params->cryptoctx, &err);
 		if (!sigvalidity) {
 		    fprintf (stderr, "Failed to verify signed part: %s\n", (err ? err->message : "no error explanation given"));
 		}
 		if ((selected || state->in_zone) && format->part_sigstatus)
 		    format->part_sigstatus (sigvalidity);
 		if (sigvalidity)
-		    g_mime_signature_validity_free (sigvalidity);
+		    g_object_unref (sigvalidity);
 	    }
 	}
 
